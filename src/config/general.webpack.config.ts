import * as fs from "fs";
import * as webpack from "webpack";
import {Entry, EntryFunc} from "webpack";
import CSS from "./rules/css";
import {file} from "./rules/files";
import {context, isDebug, isDevelopment, modules, stats} from "./target.config";

class WatchTimestampsPlugin {
  private patterns: any;

  constructor(patterns: any) {
    this.patterns = patterns;

    this.apply = this.apply.bind(this);
  }

  public apply(compiler: webpack.Compiler) {
    compiler.plugin("watch-run", (watch, callback) => {

      Object
        .keys(watch.compiler.fileTimestamps)
        .forEach(
          (filePath) => {
            if (
              this.patterns.some((pat: RegExp | string) => pat instanceof RegExp
                ? pat.test(filePath)
                : filePath.indexOf(pat) === 0)
            ) {
              watch.compiler.fileTimestamps[filePath] = fs.statSync(filePath).mtime;
            }
          },
        );
      callback();
    });
  }
}

export default (
  entry: string | string[] | Entry | EntryFunc,
  output: webpack.Output,
  rules: webpack.Rule[],
  plugins: webpack.Plugin[],
  externals: webpack.ExternalsFunctionElement | webpack.ExternalsObjectElement | webpack.ExternalsElement,
): webpack.Configuration => ({
  bail: !isDevelopment,
  // cache: true,
  context,
  devtool: isDebug ? "source-map" : false,
  entry,
  externals,
  module: {
    rules: [...CSS(), file(), ...rules],
  },
  output,
  performance: {
    hints: false,
  },
  plugins: [
    // Ignore declaration files generated by typings-for-css-module-loader.
    new webpack.WatchIgnorePlugin([/css\.d\.ts$/]),
    // ...but ensure they are still picked up by ts-loader's caching mechanism.
    new WatchTimestampsPlugin([/css\.d\.ts$/]),
    ...plugins,
  ],
  resolve: {
    extensions: [".js", ".ts", ".tsx", ".css", ".json"],
    modules,
  },
  resolveLoader: {
    extensions: [".js", ".json"],
    mainFields: ["loader", "main"],
    modules,
  },
  stats,
});
